<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Envoltória Convexa - Quickhull O(n log n)</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      background: #fff;
      display: flex;
      flex-direction: column;
      align-items: center;
      margin: 0;
      padding: 20px;
    }

    canvas {
      border: 1px solid #ccc;
      margin-top: 10px;
      cursor: crosshair;
    }

    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-bottom: 10px;
      justify-content: center;
    }

    button {
      padding: 8px 12px;
      font-size: 14px;
      cursor: pointer;
      background: #f5f5f5;
      border: 1px solid #ccc;
      border-radius: 4px;
      transition: background 0.2s;
    }

    button:hover {
      background: #e5e5e5;
    }

    .delay-control {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    input[type="range"] {
      width: 120px;
    }

    #status {
      margin-top: 10px;
      font-size: 18px;
      font-weight: bold;
      color: #333;
    }
  </style>
</head>
<body>
  <h2>Envoltória Convexa - Quickhull O(n log n)</h2>
  <div class="controls">
    <button id="resetBtn">Resetar</button>
    <button id="playBtn">Play</button>
    <button id="prevBtn">Voltar</button>
    <button id="nextBtn">Avançar</button>
    <button id="computeBtn">Gerar Hull (Quickhull)</button>
    <div class="delay-control">
      <label for="delayRange">Delay:</label>
      <input type="range" id="delayRange" min="50" max="3000" step="50" value="300" />
      <span id="delayValue">300 ms</span>
    </div>
  </div>
  <canvas id="canvas" width="800" height="500"></canvas>
  <div id="status">Passo: -</div>

  <script>
    // --- Elementos e estado ---
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    const delayRange = document.getElementById("delayRange");
    const delayValue = document.getElementById("delayValue");
    const statusDiv = document.getElementById("status");

    let points = [];
    let steps = []; // cada step = { type: 'test'|'select'|'add', line: [p1,p2], candidate: p?, hullEdges: [ [p,p], ... ], note: string }
    let currentStep = 0;
    let playing = false;
    let delay = parseInt(delayRange.value);
    let intervalId = null;

    delayRange.addEventListener("input", () => {
      delay = parseInt(delayRange.value);
      delayValue.textContent = `${delay} ms`;
    });

    canvas.addEventListener("click", (e) => {
      if (playing) return;
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      points.push({ x, y });
      draw();
    });

    
    function cross(a, b, c) {
      // cross product of AB x AC
      return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);
    }

    function distancePointToLine(a, b, p) {
      // area of triangle * 2 = abs(cross(a,b,p))
      return Math.abs(cross(a, b, p));
    }

    function draw(pointsToHighlight = null, hullLines = []) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Desenhar hullLines (arestas da envoltória)
      ctx.strokeStyle = "red";
      ctx.lineWidth = 2;
      for (const line of hullLines) {
        ctx.beginPath();
        ctx.moveTo(line[0].x, line[0].y);
        ctx.lineTo(line[1].x, line[1].y);
        ctx.stroke();
      }

      // Pontos
      ctx.fillStyle = "blue";
      ctx.font = "12px Arial";
      points.forEach((p, i) => {
        ctx.beginPath();
        ctx.arc(p.x, p.y, 5, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillText(i + 1, p.x + 8, p.y - 8);
      });

      // Se linha de teste informada, desenhar
      if (pointsToHighlight && pointsToHighlight.line) {
        const [p1, p2] = pointsToHighlight.line;

        // Linha base (tracejada cinza)
        ctx.strokeStyle = "gray";
        ctx.setLineDash([6, 6]);
        ctx.beginPath();
        ctx.moveTo(p1.x, p1.y);
        ctx.lineTo(p2.x, p2.y);
        ctx.stroke();
        ctx.setLineDash([]);

        // Linha estendida (vermelha fina) atravessando canvas
        ctx.strokeStyle = "orange";
        ctx.lineWidth = 1;
        const dx = p2.x - p1.x;
        const dy = p2.y - p1.y;
        if (dx === 0) {
          ctx.beginPath();
          ctx.moveTo(p1.x, 0);
          ctx.lineTo(p1.x, canvas.height);
          ctx.stroke();
        } else {
          const m = dy / dx;
          const b = p1.y - m * p1.x;
          const x0 = 0;
          const y0 = m * x0 + b;
          const x1 = canvas.width;
          const y1 = m * x1 + b;
          ctx.beginPath();
          ctx.moveTo(x0, y0);
          ctx.lineTo(x1, y1);
          ctx.stroke();
        }

        // Se houver candidate (ponto mais distante), desenhar triângulo
        if (pointsToHighlight.candidate) {
          const c = pointsToHighlight.candidate;
          ctx.strokeStyle = "purple";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(p1.x, p1.y);
          ctx.lineTo(p2.x, p2.y);
          ctx.lineTo(c.x, c.y);
          ctx.closePath();
          ctx.stroke();

          // marcar candidate
          ctx.fillStyle = "purple";
          ctx.beginPath();
          ctx.arc(c.x, c.y, 6, 0, Math.PI * 2);
          ctx.fill();
        }
      }
    }
    
    function generateQuickhullSteps() {
      steps = [];
      if (points.length < 3) {
        // nada a fazer: hull = todos pontos
        const hullEdges = [];
        for (let i = 0; i < points.length; i++) {
          for (let j = i + 1; j < points.length; j++) hullEdges.push([points[i], points[j]]);
        }
        steps.push({ type: "done", hullEdges, note: "Menos de 3 pontos" });
        return;
      }

      // achar o ponto com menor x (A) e maior x (B)
      let minX = points[0], maxX = points[0];
      for (const p of points) {
        if (p.x < minX.x || (p.x === minX.x && p.y < minX.y)) minX = p;
        if (p.x > maxX.x || (p.x === maxX.x && p.y > maxX.y)) maxX = p;
      }

      // borda inicial
      const hullEdges = [];

      // registrar passo inicial (linha AB)
      steps.push({ type: "test", line: [minX, maxX], candidate: null, hullEdges: [...hullEdges], note: "Linha inicial AB" });

      // divide em dois lados
      const leftSet = [], rightSet = [];
      for (const p of points) {
        if (p === minX || p === maxX) continue;
        const c = cross(minX, maxX, p);
        if (c > 0) leftSet.push(p); // acima da linha
        else if (c < 0) rightSet.push(p); // abaixo da linha
        // colineares são ignorados (ficam na aresta)
      }

      // Função recursiva que processa um lado e popula hullEdges e steps
      function processSet(a, b, set) {
        // a,b define segmento orientado
        steps.push({ type: "test", line: [a, b], candidate: null, hullEdges: [...hullEdges], note: `Processando conjunto para aresta ${indexOfPoint(a)}-${indexOfPoint(b)}` });

        if (set.length === 0) {
          // b está direto conectado a a na hull (nenhum ponto por fora)
          hullEdges.push([a, b]);
          steps.push({ type: "add", line: [a, b], candidate: null, hullEdges: [...hullEdges], note: `Adicionar aresta ${indexOfPoint(a)}-${indexOfPoint(b)} (sem pontos)` });
          return;
        }

        // achar ponto p_max com maior distância a-b (max cross magnitude)
        let maxP = set[0];
        let maxDist = distancePointToLine(a, b, maxP);
        for (const p of set) {
          const d = distancePointToLine(a, b, p);
          if (d > maxDist) {
            maxDist = d;
            maxP = p;
          }
        }

        // registrar seleção do ponto mais distante
        steps.push({ type: "select", line: [a, b], candidate: maxP, hullEdges: [...hullEdges], note: `Selecionado ponto mais distante ${indexOfPoint(maxP)} da aresta ${indexOfPoint(a)}-${indexOfPoint(b)} (área máxima)` });

        // dividir set em S1: pontos à esquerda de (a,maxP) e S2: pontos à esquerda de (maxP,b)
        const s1 = [], s2 = [];
        for (const p of set) {
          if (p === maxP) continue;
          // ponto está à esquerda da aresta (a, maxP)?
          const c1 = cross(a, maxP, p);
          if (c1 > 0) s1.push(p);
          const c2 = cross(maxP, b, p);
          if (c2 > 0) s2.push(p);
        }

        // Recursão: processar (a, maxP) e (maxP, b)
        processSet(a, maxP, s1);
        processSet(maxP, b, s2);
      }

      // auxiliares
      function indexOfPoint(p) {
        const i = points.indexOf(p);
        return i >= 0 ? (i + 1) : '?';
      }

      // processar os dois lados: left (minX->maxX) e right (maxX->minX)
      processSet(minX, maxX, leftSet);
      processSet(maxX, minX, rightSet);

      // passo final: marcar done com hullEdges ordenadas
      steps.push({ type: "done", hullEdges: [...hullEdges], note: "Concluído" });
    }
    
    function showStep() {
      if (steps.length === 0) {
        statusDiv.textContent = "Passo: -";
        draw();
        return;
      }
      if (currentStep < 0) currentStep = 0;
      if (currentStep >= steps.length) currentStep = steps.length - 1;
      const s = steps[currentStep];

      // atualizar desenho conforme tipo
      if (s.type === "test") {
        draw({ line: s.line, candidate: null }, s.hullEdges);
      } else if (s.type === "select") {
        draw({ line: s.line, candidate: s.candidate }, s.hullEdges);
      } else if (s.type === "add") {
        draw(null, s.hullEdges);
      } else if (s.type === "done") {
        draw(null, s.hullEdges);
      } else {
        draw();
      }

      // atualizar status textual
      let statusText = `Passo ${currentStep + 1}/${steps.length}: ${s.note || s.type}`;
      if (s.type === "select" && s.candidate) {
        const i = points.indexOf(s.candidate) + 1;
        statusText += ` — candidato: ${i}`;
      }
      statusDiv.textContent = statusText;
    }

    function playAnimation() {
      if (steps.length === 0) return;
      if (!playing) {
        playing = true;
        document.getElementById("playBtn").textContent = "Pause";
        intervalId = setInterval(() => {
          showStep();
          currentStep++;
          if (currentStep >= steps.length) {
            clearInterval(intervalId);
            playing = false;
            document.getElementById("playBtn").textContent = "Play";
            currentStep = steps.length - 1;
            showStep();
          }
        }, delay);
      } else {
        clearInterval(intervalId);
        playing = false;
        document.getElementById("playBtn").textContent = "Play";
      }
    }

    document.getElementById("resetBtn").addEventListener("click", () => {
      points = [];
      steps = [];
      currentStep = 0;
      playing = false;
      clearInterval(intervalId);
      document.getElementById("playBtn").textContent = "Play";
      statusDiv.textContent = "Passo: -";
      draw();
    });

    document.getElementById("playBtn").addEventListener("click", () => {
      if (steps.length === 0) return;
      playAnimation();
    });

    document.getElementById("nextBtn").addEventListener("click", () => {
      if (steps.length === 0) return;
      currentStep = Math.min(currentStep + 1, steps.length - 1);
      showStep();
    });

    document.getElementById("prevBtn").addEventListener("click", () => {
      if (steps.length === 0) return;
      currentStep = Math.max(currentStep - 1, 0);
      showStep();
    });

    document.getElementById("computeBtn").addEventListener("click", () => {
      if (points.length < 3) {
        alert("Adicione ao menos 3 pontos.");
        return;
      }
      // gerar steps fresh
      generateQuickhullSteps();
      currentStep = 0;
      showStep();
    });

    // desenhar inicialmente
    draw();

    // --- (opcional) tecla 'c' limpa, 'g' gera hull ---
    window.addEventListener("keydown", (e) => {
      if (e.key === "c") {
        document.getElementById("resetBtn").click();
      } else if (e.key === "g") {
        document.getElementById("computeBtn").click();
      }
    });

    // Ajuste para redimensionamento visual (mantém canvas CSS fixa mas pega devicePixelRatio)
    function fixHiDPI() {
      const dpr = window.devicePixelRatio || 1;
      const w = canvas.width;
      const h = canvas.height;
      canvas.width = w * dpr;
      canvas.height = h * dpr;
      canvas.style.width = w + "px";
      canvas.style.height = h + "px";
      ctx.scale(dpr, dpr);
    }
    // Chamar apenas uma vez ao carregar
    // (Se preferir comentar, mantenha a escala original)
    // fixHiDPI();
  </script>
</body>
</html>
